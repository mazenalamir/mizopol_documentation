{"title":"Overview","markdown":{"yaml":{"title":"Overview","subtitle":"The mizopol suite in a glance."},"headingText":"`plars`","containsRefs":false,"markdown":"\n\n***\n\nThe **mizopol** suite currently consists of the following modules that are presented in details through this documentation. \n\nThe presentation below aims at giving a brief and sketchy overview of the tools. \n\n\n\n:::{.columns}\n:::{.column width=\"45%\"}\nIdentify a sparse multi-variate polynomial[^poly] $P$ such that:\n$$y\\approx P(x)$$ \n\nThe algorithm is based on a modified, **scalable version** of the `LARS` (least angle) algorithm. \n\nThe `plars` module is detailed [here](plars_intro.qmd).\n\n***\n\n:::{.small-gray-light}\n**M. Alamir**, Nonlinear control of uncertain systems: conventional and data driven alternatives with python. **Springer-Nature**, November, 2025\n:::\n\n[^poly]: see the [polynomial](polynomials.qmd) page for a rigorous definition.\n:::\n\n:::{.column width=\"5%\"}\n \n:::\n:::{.column width=\"50%\"}\n\n```python\nfrom plars import PLARS, predict \n\n# Create an instance of the PLARS class\npl = PLARS(\n        deg=3, \n        window=1000, \n        nModes=10, \n        nModels=10, \n        eps=0.05\n)\n\n# Fit the data and get the solution \nsol = pl.fit(X, y , ...)\n\n# Predict on new data with sol \nypred = predict(Xtest, sol)\n```\n:::\n:::\n\n\n# `g2sys`\n\n:::{.columns}\n:::{.column width=\"58%\"}\nGiven sensors $s_1$, ..., $s_n$, \nfit a set of relationships of one of the following two forms: \n\n:::{.small}\n\n:::{.callout-note title='Static'}\n**Static**\n$$\ns_i(k)=F_i\\left(\\{s_j(k-\\sigma\\times d_i)\\}_{(j\\neq i,\\sigma\\in \\{0,\\dots,m_i\\})}\\right)\n$$\n $\\rightarrow$ $s_i$ is a static function of the other sensors and their past values up to $m_i\\times d_i$.\n:::\n\n:::{.callout-note title='Dynamic'}\n\n**Dynamic**\n$$\n\\Delta s_i(k)=F_i\\left(\\begin{array}\n\\{s_i(k-\\sigma\\times d_i)\\}_{\\sigma\\in \\{1,\\dots,m_i\\}}\\cr \n\\{s_j(k-\\sigma\\times d_i)\\}_{(j\\neq i,\\sigma\\in \\{0,\\dots,m_i\\})}\n\\end{array}\n\\right)\n$$\n$\\rightarrow$ The increment $\\Delta s_i:=s_i(k)-s_i(k-d_i)$ of $s_i$ is a static function of the all sensors and their past values up to $m_i\\times d_i$.\n:::\nCan be use to achieve the following tasks: \n\n- Design **explainable** normality indicators \n- **Discover** unmodelled **relationships**\n- Help designing Dynamic **Digital Twins** \n- **Detecting contexts** in the datasets\n- Remove **redundant sensors**\n- Survey **persistant correlations**\n\nThe **g2sys** module is detailed [here](g2sys_intro.qmd)\n\n:::\n:::\n\n:::{.column width=1%}\n \n:::\n\n:::{.column width=\"41%\"}\n\n:::{.panel-tabset}\n\n# Objective\n\n![Discover the graph of coupling. Undertand the equiment and how the available sensors connect to each other as far as the dataset can tell.](images/g2sys_graph.png){ style=\"border: 0px solid #498aa6ff; border-radius: 0px;\" }\n\n# Screenshot\n![A user friendly and responsive environment to discover the relationship by manipulating the model's parameters $d_i$, $m_i$, `static`, `dynamic` etc.](images/g2sys_overview.png){ style=\"border: 0px solid #498aa6ff; border-radius: 0px;\" }\n:::\n\n:::\n:::\n\n# `pwpol`\n\n:::{.columns}\n:::{.column width=\"55%\"}\nGiven a set of sensors $s_j$, $j=1,\\dots,n_s$ and a target sensor $s_i$, find a set of $n_r$ polynomials $P_\\sigma$, $\\sigma=1,\\dots,n_r$, such that the following residual: \n$$\ne_i = \\min_{\\sigma=1}^{n_r}\\Bigl\\vert s_i-P_\\sigma(\\{s_j\\}_{j\\neq i})\\Bigr\\vert\n$${#eq-residual-implicit}\nis small.\n\nNotice that: \n\n- @eq-residual-implicit defines an **implicit** invariant describing the normality of the system should the dataset on which it is computed be healthy.\n\n- The number $n_r$ of polynomials should be made as small as possible.\n\n- @eq-residual-implicit does not provide a *prediction* capability since the residual can be computed only when the measurement $s_i$ is available. \n\nThe **pwpol** module is detailed [here](pwp_intro.qmd).\n\n:::{.column width=2%}\n \n:::\n\n:::\n:::{.column width=\"42%\"}\n![Schematic view of a piece-wise defined relationship with two regions $\\mathcal R_a$ and $\\mathcal R_b$ and the random search hypercubes used in the `pwpol` module.](images/piece_wise.png){width=100%} \n:::\n:::\n\n# `rlars`\n\n:::{.columns}\n\n::: {.column width=50%}\nGiven \n\n- a features vector $x$ and \n- a label $y$, \n\nfind a set of multi-variate polynomials: \n\n$$\nc_0(x),\\dots, c_r(x)\n$$\n\nsuch that $y$ is a root of the following scalar polyomial (in the unknown $z$):\n\n$$\nc_r(x)z^r+\\dots+c_1(x)z+c_0(x)\n$$\n\nMore precisely, the following can be viewed as a residual for the normality characterization of the pair $(x,y)$: \n\n$$\nR(x,y):=\\sum_{j=0}^rc_j(x)y^j\n$${#eq-residualofrlars}\n\n:::\n::: {.column width=2%}\n \n:::\n\n::: {.column width=47%}\n\n:::{.callout-note title=\"Rational functions\"}\nThe starting point of this structure is that in the particular case where $r=1$, @eq-residualofrlars simply implies that:\n$$\ny = -\\dfrac{c_0(x)}{c_1(x)}\n$$\n\nwhich is simply a multi-variate fractional expression in the features vector $x$. \n\nThis generalizes the polynomial structure targeted by `plars`. \n\nNotice however that this is only the starting point, the results obviously offer a much wider generalization than simply fractional representation when $r>1$. \n:::\n\n:::\n\n:::\n\n# `xpwpol` \n\n:::{.columns}\n\n::: {.column width=50%}\nGiven \n\n- a features vector $x$ and \n- a label $y$, \n\nthe `xpwpol` module enables to design relationships of the form: \n\n$$\ny = P_{\\mathcal R(x)}(x) \n$$\n\nwhere \n\n- $\\mathcal R(x)\\in \\{1,\\dots,n_r\\}$ is a region map \n\n- $P_j$ for $j\\in \\{1,\\dots,n_r\\}$ is the multi-variate polynomial that represents the relationship between $x$ and $y$ in the associated region of the features space.\n:::\n::: {.column width=2%}\n \n:::\n\n::: {.column width=47%}\n\n![Given a features vector $x$, the region map $\\mathcal R(x)$ determines which polynomial should be used to predict the value of the label $y$](images/illustration_xpwpol_overview.png)\n\n:::\n","srcMarkdownNoYaml":"\n\n***\n\nThe **mizopol** suite currently consists of the following modules that are presented in details through this documentation. \n\nThe presentation below aims at giving a brief and sketchy overview of the tools. \n\n\n# `plars`\n\n:::{.columns}\n:::{.column width=\"45%\"}\nIdentify a sparse multi-variate polynomial[^poly] $P$ such that:\n$$y\\approx P(x)$$ \n\nThe algorithm is based on a modified, **scalable version** of the `LARS` (least angle) algorithm. \n\nThe `plars` module is detailed [here](plars_intro.qmd).\n\n***\n\n:::{.small-gray-light}\n**M. Alamir**, Nonlinear control of uncertain systems: conventional and data driven alternatives with python. **Springer-Nature**, November, 2025\n:::\n\n[^poly]: see the [polynomial](polynomials.qmd) page for a rigorous definition.\n:::\n\n:::{.column width=\"5%\"}\n \n:::\n:::{.column width=\"50%\"}\n\n```python\nfrom plars import PLARS, predict \n\n# Create an instance of the PLARS class\npl = PLARS(\n        deg=3, \n        window=1000, \n        nModes=10, \n        nModels=10, \n        eps=0.05\n)\n\n# Fit the data and get the solution \nsol = pl.fit(X, y , ...)\n\n# Predict on new data with sol \nypred = predict(Xtest, sol)\n```\n:::\n:::\n\n\n# `g2sys`\n\n:::{.columns}\n:::{.column width=\"58%\"}\nGiven sensors $s_1$, ..., $s_n$, \nfit a set of relationships of one of the following two forms: \n\n:::{.small}\n\n:::{.callout-note title='Static'}\n**Static**\n$$\ns_i(k)=F_i\\left(\\{s_j(k-\\sigma\\times d_i)\\}_{(j\\neq i,\\sigma\\in \\{0,\\dots,m_i\\})}\\right)\n$$\n $\\rightarrow$ $s_i$ is a static function of the other sensors and their past values up to $m_i\\times d_i$.\n:::\n\n:::{.callout-note title='Dynamic'}\n\n**Dynamic**\n$$\n\\Delta s_i(k)=F_i\\left(\\begin{array}\n\\{s_i(k-\\sigma\\times d_i)\\}_{\\sigma\\in \\{1,\\dots,m_i\\}}\\cr \n\\{s_j(k-\\sigma\\times d_i)\\}_{(j\\neq i,\\sigma\\in \\{0,\\dots,m_i\\})}\n\\end{array}\n\\right)\n$$\n$\\rightarrow$ The increment $\\Delta s_i:=s_i(k)-s_i(k-d_i)$ of $s_i$ is a static function of the all sensors and their past values up to $m_i\\times d_i$.\n:::\nCan be use to achieve the following tasks: \n\n- Design **explainable** normality indicators \n- **Discover** unmodelled **relationships**\n- Help designing Dynamic **Digital Twins** \n- **Detecting contexts** in the datasets\n- Remove **redundant sensors**\n- Survey **persistant correlations**\n\nThe **g2sys** module is detailed [here](g2sys_intro.qmd)\n\n:::\n:::\n\n:::{.column width=1%}\n \n:::\n\n:::{.column width=\"41%\"}\n\n:::{.panel-tabset}\n\n# Objective\n\n![Discover the graph of coupling. Undertand the equiment and how the available sensors connect to each other as far as the dataset can tell.](images/g2sys_graph.png){ style=\"border: 0px solid #498aa6ff; border-radius: 0px;\" }\n\n# Screenshot\n![A user friendly and responsive environment to discover the relationship by manipulating the model's parameters $d_i$, $m_i$, `static`, `dynamic` etc.](images/g2sys_overview.png){ style=\"border: 0px solid #498aa6ff; border-radius: 0px;\" }\n:::\n\n:::\n:::\n\n# `pwpol`\n\n:::{.columns}\n:::{.column width=\"55%\"}\nGiven a set of sensors $s_j$, $j=1,\\dots,n_s$ and a target sensor $s_i$, find a set of $n_r$ polynomials $P_\\sigma$, $\\sigma=1,\\dots,n_r$, such that the following residual: \n$$\ne_i = \\min_{\\sigma=1}^{n_r}\\Bigl\\vert s_i-P_\\sigma(\\{s_j\\}_{j\\neq i})\\Bigr\\vert\n$${#eq-residual-implicit}\nis small.\n\nNotice that: \n\n- @eq-residual-implicit defines an **implicit** invariant describing the normality of the system should the dataset on which it is computed be healthy.\n\n- The number $n_r$ of polynomials should be made as small as possible.\n\n- @eq-residual-implicit does not provide a *prediction* capability since the residual can be computed only when the measurement $s_i$ is available. \n\nThe **pwpol** module is detailed [here](pwp_intro.qmd).\n\n:::{.column width=2%}\n \n:::\n\n:::\n:::{.column width=\"42%\"}\n![Schematic view of a piece-wise defined relationship with two regions $\\mathcal R_a$ and $\\mathcal R_b$ and the random search hypercubes used in the `pwpol` module.](images/piece_wise.png){width=100%} \n:::\n:::\n\n# `rlars`\n\n:::{.columns}\n\n::: {.column width=50%}\nGiven \n\n- a features vector $x$ and \n- a label $y$, \n\nfind a set of multi-variate polynomials: \n\n$$\nc_0(x),\\dots, c_r(x)\n$$\n\nsuch that $y$ is a root of the following scalar polyomial (in the unknown $z$):\n\n$$\nc_r(x)z^r+\\dots+c_1(x)z+c_0(x)\n$$\n\nMore precisely, the following can be viewed as a residual for the normality characterization of the pair $(x,y)$: \n\n$$\nR(x,y):=\\sum_{j=0}^rc_j(x)y^j\n$${#eq-residualofrlars}\n\n:::\n::: {.column width=2%}\n \n:::\n\n::: {.column width=47%}\n\n:::{.callout-note title=\"Rational functions\"}\nThe starting point of this structure is that in the particular case where $r=1$, @eq-residualofrlars simply implies that:\n$$\ny = -\\dfrac{c_0(x)}{c_1(x)}\n$$\n\nwhich is simply a multi-variate fractional expression in the features vector $x$. \n\nThis generalizes the polynomial structure targeted by `plars`. \n\nNotice however that this is only the starting point, the results obviously offer a much wider generalization than simply fractional representation when $r>1$. \n:::\n\n:::\n\n:::\n\n# `xpwpol` \n\n:::{.columns}\n\n::: {.column width=50%}\nGiven \n\n- a features vector $x$ and \n- a label $y$, \n\nthe `xpwpol` module enables to design relationships of the form: \n\n$$\ny = P_{\\mathcal R(x)}(x) \n$$\n\nwhere \n\n- $\\mathcal R(x)\\in \\{1,\\dots,n_r\\}$ is a region map \n\n- $P_j$ for $j\\in \\{1,\\dots,n_r\\}$ is the multi-variate polynomial that represents the relationship between $x$ and $y$ in the associated region of the features space.\n:::\n::: {.column width=2%}\n \n:::\n\n::: {.column width=47%}\n\n![Given a features vector $x$, the region map $\\mathcal R(x)$ determines which polynomial should be used to predict the value of the label $y$](images/illustration_xpwpol_overview.png)\n\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","number-sections":true,"html-math-method":"mathjax","css":["styles/styles.css"],"toc":true,"output-file":"overview.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.32","bibliography":["biblio.bib"],"resources":["images/sparsity_osc_*.png","images/anomalies_detection_pbstat_*.png","images/sources_of_anomalies_*.png","images/zema_*.png"],"theme":"flatly","link-citations":true,"csl":"styles/apa.csl","title":"Overview","subtitle":"The mizopol suite in a glance."},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}