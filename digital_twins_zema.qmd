---
title: Digital Twins
subtitle: From dataframes to simulator of a hydraulic rig
---

***

## The dataset 

:::{.columns}
:::{.column width=45%}
**Zema** Dataset
: This is a public dataset that is available at [UC Irvine Machine Learning Repository](https://archive.ics.uci.edu/dataset/447/condition+monitoring+of+hydraulic+systems).

***

This system has been already encoutered in this documentation (see [the g2sys module presentation](g2sys_zema.qmd) and [the introduction on the concept of graph](graph_zema.qmd) for some examples and movies of identification relationships). In this section, we start from a set of already identified relationships and proceed for the presentation of the rationale of constructing the Digital Twin for this system[^possibility]. 


 | **7** sensors | **255,420** rows |

:::

:::{.column width=4%}
 
:::


:::{.column width=50%}
![Can we use the dataset representing time-series to quickly derive a dynamic simulator of the system (The above AI-generated photo is used for illustrative purpose and is not directly related to the dataset.)](images/zema_process.png){width=95% fig-align="right"}
:::
:::

***

## The identified relationships 

The **g2sys** module has been used (as shown previously) to derive a set of polynomial relationships that might be static (non recursive) or dynamic (recursive) that are each indexed by one of the sensors. 

The fitting provided by these relationships is shown on the snapshots below which are extracted from the **g2sys** module. Notice that each screenshot shows an appropriate zoom on the predicted and the measured value, the head of the screenshot introduces the sensor indexing the relationship, the *pickled* file containing the solution, the number of parameters involved (card) and the type of relationship (static/dynamic). The right hand side dataframe shows the other sensors involved  in the relationship, other than the sensor indexing the relationship. 

<div class="slideshow">
  <img id="slide1" src="images/zema_PS1.png" width="100%">
  <br>
  <button onclick="prev1()">Previous</button>
  <button onclick="next1()">Next</button>
</div>

<script>
(() => {
  const images1 = [
    "images/zema_PS1.png",
    "images/zema_PS2.png",
    "images/zema_PS3.png",
    "images/zema_PS5.png",
    "images/zema_EPS1.png",
    "images/zema_PS6.png",
  ];
  let index1 = 0;

  function show1() {
    document.getElementById("slide1").src = images1[index1];
  }
  window.next1 = () => { index1 = (index1 + 1) % images1.length; show1(); };
  window.prev1 = () => { index1 = (index1 - 1 + images1.length) % images1.length; show1(); };
})();
</script>

## The graph of the system

Based on the above relationships, the following graph can also be displayed in the **g2sys** module:

![The graph of relationships between the sensors present in the Zema dataset as shown in the **g2sys** module.](images/graph_zema_DT.png)

A simple observation of the graph provides the following information: 

1. `PS1`and `PS4` are not indices of any relationship and therefore, they are **exogenous inputs** to the simulator.

2. The graph decomposes the system into **two groups of sensors**, the first is fed by the exogenous signal `PS1` while the second is fed by the exogenous signal `PS4`.

3. `PS6` is defined by a recursive relationship with the only input `PS4` which means that it can be simulated alone independently of the other sensors. 

4. `PS5` is defined completely from `PS6`. 

5. `EPS1` is statically defined as a function of `PS1` and the resulting pair (`PS1`, `EPS1`) uniquely determines `PS2`.

6. `PS3` is defined by a dynamic relationship involving `PS2` as leading sensor.

The whole above discussion can be summarized by the following Digital Twin schematic

![Functional view of the Digital Twin showing the two subsystems and the two different sampling periods $\{5, 20\}$ used in each one. ](images/zema_DT_simulator.png){#fig-functional-view}


## The relationships $F_i$ as polynomials

Recall that **g2sys** module identifies relationships as sparse multi-variate polynomial in the sensors and possibly their delayed values. The polynomials have been defined in the [dedicated section](polynomials.qmd). Nevertheless, the definition is reported here for an easy reading: 

$$
P(x)=\sum_{i=1}^{n_c} c_i\phi_i(x)\quad\text{where}\quad \phi_i(x) = \prod_{j=1}^{n}x_j^{p_{ij}} 
$$

which obviously highlights that a polynomial is defined by the definition of: 

- The vector of input argument $x$
- The matrix of powers $P$
- The vector of coefficients $c$

![Attributes of a monomial in a polynomial in $n$ arguments](images/attributes_monomial.png){#fig-attributes-mono width="80%"}

The different relationships $F_i$ invoked above are quatitatively exposed below using the following script that uses the `model` object returned by the **g2sys** module: 

```python 
for i in range(len(model)):
    s = list(model[i].keys())[0]
    print(f'{i} Relationship indexed by {s}')
    print('==================================')
    print(f"arguments: {model[i][s]['Lred']}")
    print('--------')
    print(f"powers \n {model[i][s]['powers']}")
    print('--------')
    print(f"coefficients: \n {model[i][s]['coefs']}")
    print('---')
```

:::{.panel-tabset}

# F5

```terminal
0 Relationship indexed by PS5
==================================
arguments: ['PS6(k)']
--------
powers 
 [[1]]
--------
coefficients: 
 [1.01204197]
```

# F6

```terminal
1 Relationship indexed by PS6
==================================
arguments: ['PS4(k)', 'PS6(k-5)', 'PS4(k-5)']
--------
powers 
 [[0 7 0]
 [7 0 0]
 [0 0 7]]
--------
coefficients: 
 [ 4.24551785e-10 -1.26887138e-07  1.26536849e-07]
```

# F2

```terminal
2 Relationship indexed by PS2
==================================
arguments: ['PS1(k)', 'EPS1(k)']
--------
powers 
 [[0 0]
 [7 0]
 [2 0]
 [1 0]
 [0 5]
 [0 7]
 [2 4]
 [1 4]
 [0 6]
 [2 5]
 [2 2]
 [0 3]
 [1 3]]
--------
coefficients: 
 [-1.60070178e+01  2.69116140e-13 -2.01153924e+00  1.94358046e+02
  2.68563176e-13 -1.08337198e-20 -9.94726683e-14  3.35975706e-12
 -1.08849622e-17  1.67660452e-17  5.11233178e-07 -2.49710828e-06
 -1.34518741e-09]
```

# F3

```terminal 
3 Relationship indexed by PS3
==================================
arguments: ['PS2(k)', 'PS3(k-20)', 'PS2(k-20)']
--------
powers 
 [[0 1 3]
 [0 1 0]
 [5 0 0]
 [2 0 0]
 [4 1 0]
 [0 2 0]
 [0 3 0]
 [0 5 0]
 [0 1 2]
 [3 0 0]
 [3 2 0]
 [1 0 0]
 [2 0 3]
 [0 4 0]
 [0 1 1]
 [4 0 0]
 [0 1 4]
 [1 0 2]
 [1 0 4]]
--------
coefficients: 
 [ 1.53869689e-04 -8.29888290e+00 -1.84442936e-10  3.66707452e-04
  7.07717016e-10  3.13970159e+00 -6.20235249e-01 -2.51614370e-03
 -2.07759665e-02  1.08749688e-05 -2.82239193e-07 -2.80942438e-02
 -1.09176591e-10  6.59990851e-02  9.50487222e-01 -3.96594565e-08
 -3.77116064e-07 -3.53961657e-06  2.24793977e-10]
```

# Fe

```terminal 
4 Relationship indexed by EPS1
==================================
arguments: ['PS1(k)']
--------
powers 
 [[1]
 [0]]
--------
coefficients: 
 [ 13.09598968 441.01619799]
```

:::


Let us  defne the functions $F_i$ as defined above using the following script 

```python
import numpy as np
from plars import predict

def F2(PS1, EPS1):
    x = np.array([PS1, EPS1]).T
    val = predict(x, model[2]['PS2'])
    return val   

def F3(PS2, PS3_past, PS2_past):
    x = np.array([PS2, PS3_past, PS2_past]).T
    val = predict(x, model[3]['PS3'])
    return val[0]   

def Fe(PS1):
    x = np.array(PS1).reshape(-1,1)
    val = predict(x, model[4]['EPS1'])
    return val

def F5(PS6):
    x = np.array(PS6).reshape(-1,1)
    val = predict(x, model[0]['PS5'])
    return val

def F6(PS4, PS6_past, PS4_past):
    x = np.array([PS4, PS6_past, PS4_past]).T
    val = predict(x, model[1]['PS6'])
    return  val[0]

```

:::{.callout-warning title='About Open-loop simulation'}
It should be kept in mind that when dynamic relationships are involved, it is unrealistic tous the simulation model in **open-loop** as small identification errors might propagate along the simulation leading to totally erronous results. The dgital-twin is however useful in closed-loop mode as it gives the dependence (approximately) of the derivatices of some of the sensors in terms of other sensors.
:::




[^possibility]: As it has been disclaimed earlier, this cannot always be successful, because of the non completness of the data. More precisely, if there are quantities that impact strongly the behavior of the system which are not present in the set of sensors, then it is rigorously impossible to design a dynamic simultator from the available information. 

