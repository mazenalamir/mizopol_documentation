---
title: Digital Twins
subtitle: From dataframes to simulator of a hydraulic rig
---

***

## The dataset 

:::{.columns}
:::{.column width=45%}
**Zema** Dataset
: This is a public dataset that is available at [UC Irvine Machine Learning Repository](https://archive.ics.uci.edu/dataset/447/condition+monitoring+of+hydraulic+systems).

***

This system has been already encoutered in this documentation (see [the g2sys module presentation](g2sys_zema.qmd) and [the introduction on the concept of graph](graph_zema.qmd) for some examples and movies of identification relationships). In this section, we start from a set of already identified relationships and proceed for the presentation of the rationale of constructing the Digital Twin for this system[^possibility]. 


 | **7** sensors | **255,420** rows |

:::

:::{.column width=4%}
 
:::


:::{.column width=50%}
![Can we use the dataset representing time-series to quickly derive a dynamic simulator of the system (The above AI-generated photo is used for illustrative purpose and is not directly related to the dataset.)](images/zema_process.png){width=95% fig-align="right"}
:::
:::

***

## The identified relationships 

The **g2sys** module has been used (as shown previously) to derive a set of polynomial relationships that might be static (non recursive) or dynamic (recursive) that are each indexed by one of the sensors. 

The fitting provided by these relationships is shown on the snapshots below which are extracted from the **g2sys** module. Notice that each screenshot shows an appropriate zoom on the predicted and the measured value, the head of the screenshot introduces the sensor indexing the relationship, the *pickled* file containing the solution, the number of parameters involved (card) and the type of relationship (static/dynamic). The right hand side dataframe shows the other sensors involved  in the relationship, other than the sensor indexing the relationship. 

<div class="slideshow">
  <img id="slide1" src="images/zema_PS1.png" width="100%">
  <br>
  <button onclick="prev1()">Previous</button>
  <button onclick="next1()">Next</button>
</div>

<script>
(() => {
  const images1 = [
    "images/zema_PS1.png",
    "images/zema_PS2.png",
    "images/zema_PS3.png",
    "images/zema_PS5.png",
    "images/zema_EPS1.png",
    "images/zema_PS6.png",
  ];
  let index1 = 0;

  function show1() {
    document.getElementById("slide1").src = images1[index1];
  }
  window.next1 = () => { index1 = (index1 + 1) % images1.length; show1(); };
  window.prev1 = () => { index1 = (index1 - 1 + images1.length) % images1.length; show1(); };
})();
</script>

## The graph of the system

Based on the above relationships, the following graph can also be displayed in the **g2sys** module:

![The graph of relationships between the sensors present in the Zema dataset as shown in the **g2sys** module.](images/graph_zema_DT.png)

Ny only looking on the graph, the following information can be steered out: 

1. `PS4` is not index of any relationship and therefore, it is **an exogenous input** to the simulator.

2. `PS6` is defined by a recursive relationship with the only input `PS4` which means that it can be simulated alone independently of the other sensors. 

3. `PS5` is defined completely from `PS6`. 

4. As the remaining sensors, namely $\texttt{PS1}, \texttt{PS2}, \texttt{PS3}, \texttt{EPS1}$ are related through an **implicit and coupled set of relationships** for each  given value of the exogenous variable $\texttt{PS4}$, they can be obtained by solving a fixed-point relationship of the form: 
  $$
  z = H_1(z, \texttt{PS4})
  $${#eq-Fixed-Point}
  where:
  $$
  z=\begin{bmatrix} 
  \texttt{PS1}\cr \texttt{PS2}\cr \texttt{PS3}\cr \texttt{EPS1}
  \end{bmatrix} \quad,\quad H_1(z, \texttt{PS4}):= \begin{bmatrix} 
  \begin{array}{l} 
  F_1(\texttt{PS2}, \texttt{PS4})\cr 
  F_2(\texttt{PS1}, \texttt{PS3}, \texttt{EPS1})\cr 
  F_3(\texttt{PS2}, \texttt{EPS1})\cr 
  F_e(\texttt{PS1})
  \end{array} 
  \end{bmatrix} 
  $${#eq-H1}

    where the values can be restricted to the hypercube $\mathbb Z$ given the training data. 

    $$
    \mathbb Z=[100,200]\times [0,150]\times [0,10]\times [2000,3000]
    $$

5. Finally, by observing the time-series of `PS2` and `PS3`, it seems that there is a context exogenous variable that forces both to be $0$ as it can be observed on the figure below:

    ![](images/zema_PS2_0.png){width=70%}
    ![](images/zema_PS3_0.png){width=70%}

    This suggests that there are two different fixed-point equations to use depending on the value of this context variable, denoted hereafter by $\texttt{c}$: The first is to be used when $\texttt{c}=1$ which precisely given by @eq-Fixed-Point while the other is to be used when $\texttt{c}=0$ which is a fixed-point in the pair $(\texttt{PS1}, \texttt{EPS1})$ that can be given by:
    $$
    z = H_0(z, \texttt{PS4})\quad ;\quad H_0(z, \texttt{PS4}):= \begin{bmatrix} 
  \begin{array}{c} 
  F_1(\texttt{PS2}, \texttt{PS4})\cr 
  0\cr 0\cr 
  F_e(\texttt{PS1})
  \end{array} 
  \end{bmatrix} 
    $${#eq-H0}

The whole above discussion can be summarized by the following Digital Twin schematic

![Functional view of the Digital Twin involving the exogenous signals $\texttt{PS4}$ and $\texttt{c}\in \{0,1\}$ where $H_c$ is defined by @eq-H1 and @eq-H0](images/zema_DT_simulator.png)


## The relationships $F_i$ as polynomials

Recall that **g2sys** module identifies relationships as sparse multi-variate polynomial in the sensors and possibly their delayed values. The polynomials have been defined in the [dedicated section](polynomials.qmd). Nevertheless, the definition is reported here for an easy reading: 

$$
P(x)=\sum_{i=1}^{n_c} c_i\phi_i(x)\quad\text{where}\quad \phi_i(x) = \prod_{j=1}^{n}x_j^{p_{ij}} 
$$

which obviously highlights that a polynomial is defined by the definition of: 

- The vector of input argument $x$
- The matrix of powers $P$
- The vector of coefficients $c$

![Attributes of a monomial in a polynomial in $n$ arguments](images/attributes_monomial.png){#fig-attributes-mono width="80%"}

The different relationships $F_i$ invoked above are quatitatively exposed below using the following script that uses the `model` object returned by the **g2sys** module: 

```python 
for i in range(len(model)):
    s = list(model[i].keys())[0]
    print(f'{i} Relationship indexed by {s}')
    print('==================================')
    print(f"arguments: {model[i][s]['Lred']}")
    print('--------')
    print(f"powers \n {model[i][s]['powers']}")
    print('--------')
    print(f"coefficients: \n {model[i][s]['coefs']}")
    print('---')
```

:::{.panel-tabset}

# F1

```terminal 
0 Relationship indexed by PS1
==================================
arguments: ['PS2(k)', 'PS4(k)']
--------
powers 
 [[1 0]
 [1 1]
 [1 2]
 [0 3]
 [0 0]
 [2 1]]
--------
coefficients: 
 [-4.84246973e+00  7.99740424e-01 -4.67676520e-02  8.21090988e-04
  1.89816397e+02  9.66131922e-04]
--------
```

# F2

```terminal
4 Relationship indexed by PS2
==================================
arguments: ['PS3(k)', 'EPS1(k)']
--------
powers 
 [[3 4]
 [1 0]
 [0 0]
 [2 5]
 [0 7]
 [2 0]
 [3 0]
 [1 2]
 [1 3]
 [1 4]
 [7 0]
 [1 1]
 [0 2]
 [0 3]
 [4 0]
 [0 4]
 [6 0]
 [0 6]
 [3 1]
 [1 6]
 [4 3]
 [0 1]
 [5 0]
 [0 5]
 [1 5]
 [2 2]]
--------
coefficients: 
 [-3.12130423e-13 -1.07959665e-03  3.41523096e-05  5.83443081e-16
  8.71061363e-21  3.23647969e+00  6.05878291e+00 -1.08097761e-03
  2.09467899e-06 -1.14464575e-09  3.82493985e-03 -5.05785044e-01
  7.39024508e-03 -1.02165834e-05 -2.11840294e+01  5.08421439e-09
 -1.52476316e-01  3.01101643e-17  4.21948897e-02 -2.23320449e-17
 -2.12960283e-11  2.28246328e-02  2.50079061e+00 -1.00227759e-12
  2.63678559e-13 -4.87624150e-05]
```

# F3

```terminal
1 Relationship indexed by PS3
==================================
arguments: ['PS2(k)', 'EPS1(k)']
--------
powers 
 [[0 0]
 [5 0]
 [0 5]
 [0 3]
 [1 4]
 [0 4]]
--------
coefficients: 
 [-1.86823664e+00 -8.97436718e-11  3.86793042e-16  3.32470511e-09
  1.09409733e-15 -2.24364110e-12]
```

# Fe

```terminal 
3 Relationship indexed by EPS1
==================================
arguments: ['PS1(k)']
--------
powers 
 [[1]
 [0]]
--------
coefficients: 
 [ 13.09598968 441.01619799]
```

# F5

```terminal 
2 Relationship indexed by PS5
==================================
arguments: ['PS6(k)']
--------
powers 
 [[1]]
--------
coefficients: 
 [1.01204197]
```

# F6

```terminal 
5 Relationship indexed by PS6
==================================
arguments: ['PS6(k-4)', 'PS4(k)', 'PS4(k-4)']
--------
powers 
 [[1 0 0]
 [0 1 0]
 [0 0 1]]
--------
coefficients: 
 [ 0.00348076 -0.77680475  0.77334424]
```

:::

## Construction of the Digital Twin

### The elementary functions

Let first defne the functions $F_i$ as defined above using the following script 

```python
import numpy as np
from plars import predict

def F1(PS2, PS4):
    x = np.array([PS2, PS4]).reshape(-1,1)
    val = predict(x, model[0]['PS1'])
    return val[0]

def F2(PS3, EPS1):
    x = np.array([PS3, EPS1]).reshape(-1,1)
    val = predict(x, model[4]['PS2'])
    return val[0]   

def F3(PS2, EPS1):
    x = np.array([PS2, EPS1]).reshape(-1,1)
    val = predict(x, model[1]['PS3'])
    return val[0]   

def Fe(PS1):
    x = np.array([PS1]).reshape(-1,1)
    val = predict(x, model[3]['EPS1'])
    return val[0]

def F5(PS6):
    x = np.array([PS6]).reshape(-1,1)
    val = predict(x, model[2]['PS5'])
    return val[0]

def F6(PS6_past, PS4, PS4_past):
    x = np.array([PS6_past, PS4, PS4_past]).reshape(-1,1)
    val = predict(x, model[5]['PS6'])
    return val[0]   
```

### The fixed-point map

The first four functions enable to define the **fixed-point map $H_c$** defined by @eq-H0  and @eq-H1 using the following script[^indexasarg]: 

```python
def H(z, PS4, c):
    PS1, PS2, PS3, EPS1 = z
    if c == 1:
        zNew = np.array([F1(PS2, PS4), 
                F2(PS3, EPS1), 
                F3(PS2, EPS1), 
                Fe(PS1)])
    else:
        zNew = np.array([F1(PS2, PS4), 
                0, 0,
                Fe(PS1)])
    return zNew
```

:::{.callout-important}
It goes without saying that the fixed-point equation $z=H_c(z,\texttt{PS4})$ should not be solved on-line. It is more efficient to solve the fixed-point equation for a densed grid spanning the interval of variation (for instance $[9,11]$) for both values of the context variable $\texttt{c}\in \{0,1\}$ so that simple spline evaluation can be performed on-line.
:::

This is done in the next sections.

### Look-up tables

Let us first create a dictionary `Z` with keys: `PS4`, `0` and `1` such that: 

- `Z['PS4']` is a vector of values of `PS4` spanning [9,11]
- `Z[0]` is a for columns matrix provinding the associated values of `PS1`, `PS2`, `PS3` and `EPS1` when $\texttt{c}=0$
- `Z[1]` is a for columns matrix provinding the associated values of `PS1`, `PS2`, `PS3` and `EPS1` when $\texttt{c}=1$

Such a dictionary, used later to create the interpolation spline to be used on-line, can be viewed a a **context-dependent set of look-up tables**. It can be created using the above defined function through the following script: 

```python
set_of_PS4 = np.linspace(9, 11, 1000)

Z = {'PS4': set_of_PS4}
for c in [0,1]:
    Z[c] = []
    for iz, PS4 in enumerate(set_of_PS4):

        zact = np.array([150,0,0,2500])
        lam = 0.5
        e_past = np.linalg.norm(zact-H(zact, PS4, c), 1)
        for i in range(1000):
            zact_new = lam * H(zact, PS4, c) +(1-lam)*zact
            zact_new[1] = zact_new[2] = 0
            e = np.linalg.norm(zact_new-H(zact_new,PS4,c), 1)
            zact = 1.0 * zact_new

        efinal = np.linalg.norm(zact-H(zact, PS4, c), 1)
        Z[c].append(zact)
        if np.mod(iz,100):
            print(iz, c, efinal)
    Z[c] = np.array(Z[c])
```




[^possibility]: As it has been disclaimed earlier, this cannot always be successful, because of the non completness of the data. More precisely, if there are quantities that impact strongly the behavior of the system which are not present in the set of sensors, then it is rigorously impossible to design a dynamic simultator from the available information. 

[^indexasarg]: Notice that the index in $H_c$ is transformed into an argument of the function $H$ so that the same function can be used to evaluate $H_0(z, \texttt{PS4})$ and $H_1(z, \texttt{PS4})$.